# =========================
# MASTER (updated)
# =========================

import subprocess
import platform
from multiprocessing.connection import Listener
import time
import mss
from pynput import mouse
from pynput.mouse import Button
import threading
from collections import defaultdict
import numpy as np
from colour_grapping_2 import *
from queue import Queue, Empty
import pickle
from pathlib import Path

m = mouse.Controller()

def default_value():
    return np.zeros(27, dtype=np.float32)

Q = defaultdict(default_value)
E = defaultdict(default_value)  # eligibility traces

alpha = 0.05
gamma = 0.95
lam = 0.90

eps = 1.0
eps_min = 0.05
eps_decay = 0.995  # pr episode

def epsilon_greedy(state):
    global eps
    if np.random.rand() < eps:
        return np.random.randint(27)
    return int(np.argmax(Q[state]))

def state_from_phase(phase):
    return phase  # state is just phase index

episode_count = 0
move_count = 0  # antal moves talt

PIXEL_X = 280
PIXEL_Y = 446

sct = mss.mss()

ARM_ON_UNKNOWN = False
DEBUG = False

BPM = 124
POLL_HZ = 2 * BPM
SPEED_MULTIPLIER = 10
COOLDOWN_MS = 500 / SPEED_MULTIPLIER

# --- Restart / done detection settings (REAL SECONDS; do NOT divide by SPEED_MULTIPLIER) ---
MIN_SONG_SECONDS = 75.0          # minimum time before we allow "done"
INACTIVITY_SECONDS = 4.0         # no reward events for this long => likely end screen
DONE_POLL_HZ = 10                # done-detector sampling rate

# Coordinates for "Retry" / "Play again" click in Dolphin window (set these correctly)
RETRY_X = 100
RETRY_Y = 800

episode_start_t = time.time()
last_reward_t = time.time()

restart_request = threading.Event()
restart_in_progress = threading.Event()

phase = 0
state = state_from_phase(phase)

# clear traces at start of episode
E.clear()

a = epsilon_greedy(state)
ep_reward = 0.0

reward_lock = threading.Lock()
reward_acc = 0.0

def add_reward(r: float):
    """Called by point detector thread; also updates last_reward_t for inactivity heuristic."""
    global reward_acc, last_reward_t
    with reward_lock:
        reward_acc += r
    last_reward_t = time.time()

def pop_reward() -> float:
    global reward_acc
    with reward_lock:
        r = reward_acc
        reward_acc = 0.0
        return r

def click_at(x: int, y: int):
    """Host OS mouse click (Dolphin UI)."""
    m.position = (x, y)
    time.sleep(0.02)
    m.click(Button.left, 1)

def done_detector_loop():
    """Sets restart_request when (elapsed > MIN_SONG_SECONDS) AND (inactive > INACTIVITY_SECONDS)."""
    while True:
        time.sleep(1.0 / DONE_POLL_HZ)

        if restart_in_progress.is_set():
            continue

        elapsed = time.time() - episode_start_t
        inactive = time.time() - last_reward_t

        if elapsed >= MIN_SONG_SECONDS and inactive >= INACTIVITY_SECONDS:
            restart_request.set()

def perform_restart(conn):
    """
    Executes the restart sequence:
      1) Click retry button (host mouse)
      2) Ask slave to A-double-tap (Wiimote)
      3) Reset RL episode state
      4) Send first action of new episode
    """
    global phase, state, a, ep_reward, move_count, episode_count, eps
    global episode_start_t, last_reward_t

    restart_in_progress.set()
    restart_request.clear()

    # 1) click "Retry/Play again/OK" on the Dolphin UI (host)
    click_at(RETRY_X, RETRY_Y)
    time.sleep(0.10)

    # 2) ask slave to press A twice
    conn.send(("A_DOUBLE_TAP", None))

    # 3) episode bookkeeping + reset RL state
    episode_count += 1
    move_count = 0

    phase = 0
    state = state_from_phase(phase)

    E.clear()
    ep_reward = 0.0

    eps = max(eps_min, eps * eps_decay)
    _ = pop_reward()

    # reset timing for the next song
    episode_start_t = time.time()
    last_reward_t = time.time()

    # 4) start first action of the new episode
    a = epsilon_greedy(state)
    conn.send(("send", int(a)))

    restart_in_progress.clear()

# --- NEW: run conn loop in a thread ---
def dolphin_conn_loop(conn):
    global eps, episode_count, move_count
    global phase, state, a, ep_reward
    global episode_start_t, last_reward_t

    # reset episode timers at the moment we start acting
    episode_start_t = time.time()
    last_reward_t = time.time()

    # start first action
    conn.send(("send", int(a)))

    while True:
        reply, payload = conn.recv()

        if reply == "CLOSED":

            # 1) manual reset has priority (B only)
            if payload.get('B') and not payload.get('A'):
                move_count = 0

                phase = 0
                state = state_from_phase(phase)

                E.clear()
                a = epsilon_greedy(state)

                ep_reward = 0.0

                eps = max(eps_min, eps * eps_decay)
                _ = pop_reward()

                episode_start_t = time.time()
                last_reward_t = time.time()

                conn.send(("send", int(a)))
                continue

            # 2) auto restart (done detector) at safe boundary
            if restart_request.is_set() and not restart_in_progress.is_set():
                perform_restart(conn)
                continue

            # 3) optional existing behavior: treat B+A as "automatic reset marker"
            # (kept as you had it; this does not perform a restart by itself)
            if payload.get('B') and payload.get('A'):
                episode_count += 1

            # reward observed during the last action window
            r = pop_reward()
            ep_reward += r
            move_count += 1

            # next state (phase increments)
            phase += 1
            s2 = state_from_phase(phase)

            # choose next action
            a2 = epsilon_greedy(s2)

            # SARSA(Î») TD error
            delta = r + gamma * Q[s2][a2] - Q[state][a]

            # eligibility trace update (accumulating traces)
            E[state][a] += 1.0

            # update all traced pairs
            for s_key in list(E.keys()):
                Q[s_key] += alpha * delta * E[s_key]
                E[s_key] *= gamma * lam
                if np.max(np.abs(E[s_key])) < 1e-6:
                    del E[s_key]

            state, a = s2, a2

            # send next action to slave
            conn.send(("send", int(a)))

            print("ep", episode_count, "move", move_count, "R", ep_reward, "eps", eps, payload)


PORT = 26330
AUTHKEY = b"secret password"
DOLPHIN_EXE = r"C:/Users/esben/Downloads/dolphin-scripting-preview4-x64/dolphin"
ISO_PATH    = r"C:/Users/esben/Downloads/dolphin-2512-x64/Dolphin-x64/spil/Just_dance2.wbfs"
SCRIPT_PATH = r"C:/Users/esben/OneDrive/Documents/GitHub/Just-Dance-Project/slavetest.py"

listener = Listener(("localhost", PORT), authkey=AUTHKEY)

sysname = platform.system()
cmd = [DOLPHIN_EXE, "--no-python-subinterpreters", "--script", SCRIPT_PATH, "-b", "--exec", ISO_PATH]

print("[Master] launching:", cmd)
proc = subprocess.Popen(cmd)

print("[Master] waiting for slave connect...")
conn = listener.accept()
print("[Master] connected")

msg = conn.recv()
print("[Master] received handshake:", msg)

if __name__ == "__main__":
    # start Dolphin connection loop concurrently
    t = threading.Thread(target=dolphin_conn_loop, args=(conn,), daemon=True)
    t.start()

    # start done detector loop concurrently
    td = threading.Thread(target=done_detector_loop, daemon=True)
    td.start()

    print("Listening for new point-message events... (Ctrl+C to stop)")
    for ev in detect_point_events():
        label, r = ev["label"]   # label is ["Perfect", 1.0]
        add_reward(float(r))
